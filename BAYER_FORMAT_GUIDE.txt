================================================================================
                    Bayer 포맷 완벽 가이드
                  (Raspberry Pi Camera 기준)
================================================================================

목차
----
1. Bayer 패턴이란?
2. pGAA vs GB10 차이점
3. YUYV, MJPEG와의 관계
4. 이미지 처리 파이프라인
5. 메모리 구조 (1차원 배열)
6. 디베이어링 원리
7. 현재 프로젝트 상황
8. V4L2 표준과 추상화
9. 문서 참고 가이드


================================================================================
1. Bayer 패턴이란?
================================================================================

카메라 센서는 각 픽셀이 R(빨강), G(초록), B(파랑) 중 **하나**만 감지합니다.
이들이 격자무늬로 배열되어 있는 것을 Bayer 패턴이라고 합니다.

GBRG 패턴 (당신 카메라):
┌───┬───┬───┬───┐
│ G │ B │ G │ B │  ← 0행: Green-Blue 반복
├───┼───┼───┼───┤
│ R │ G │ R │ G │  ← 1행: Red-Green 반복
├───┼───┼───┼───┤
│ G │ B │ G │ B │  ← 2행: Green-Blue 반복
├───┼───┼───┼───┤
│ R │ G │ R │ G │  ← 3행: Red-Green 반복
└───┴───┴───┴───┘

다른 Bayer 패턴들:

RGGB:              BGGR:              GRBG:
R G R G            B G B G            G R G R
G B G B            G R G R            B G B G
R G R G            B G B G            G R G R
G B G B            G R G R            B G B G

※ 모두 같은 4개 색(R,G,G,B)이지만 시작 위치만 다릅니다!


================================================================================
2. pGAA vs GB10 차이점
================================================================================

두 포맷 모두:
- ✅ 10-bit Bayer 데이터
- ✅ GBRG 패턴 사용
- ❌ 차이점: 메모리 저장 방식

----------------------------
pGAA: 10-bit Packed
----------------------------
"Packed" = 빈틈없이 꽉 채워서 저장

4픽셀 = 5바이트 (40비트)

┌─────────────────────────────────────────┐
│ Pixel0 │ Pixel1 │ Pixel2 │ Pixel3 │     │
│ 10bit  │ 10bit  │ 10bit  │ 10bit  │     │
│ ─────────────────────────────────────── │
│         40 bits = 5 bytes               │
└─────────────────────────────────────────┘

바이트 배치:
Byte0: [Pixel0의 하위 8비트]
Byte1: [Pixel0 상위 2비트][Pixel1 하위 6비트]
Byte2: [Pixel1 상위 4비트][Pixel2 하위 4비트]
Byte3: [Pixel2 상위 6비트][Pixel3 하위 2비트]
Byte4: [Pixel3의 상위 8비트]

장점: 용량 절약 (37% 절약!)
단점: 비트 연산 필요 (복잡함)

640x480 이미지 크기: 384,000 바이트

----------------------------
GB10: 10-bit Unpacked
----------------------------
"Unpacked" = 여유있게 저장

1픽셀 = 2바이트 (16비트)

┌─────────────────────┐
│ Pixel0              │
│ 10bit + 6bit 패딩   │
│ ─────────────────── │
│  16 bits = 2 bytes  │
└─────────────────────┘

바이트 배치:
Byte0: [하위 8비트]
Byte1: [상위 2비트][000000] ← 6비트는 안 씀

장점: 데이터 추출 쉬움
단점: 용량 낭비 (60% 더 큼)

640x480 이미지 크기: 614,400 바이트


================================================================================
3. YUYV, MJPEG와의 관계
================================================================================

포맷 계층 구조:

📷 이미지 포맷
│
├─ 🔴 Raw 포맷 (센서 직접 출력)
│   ├─ Bayer 계열
│   │   ├─ pGAA (10-bit Bayer GBRG Packed) ← 당신 카메라
│   │   ├─ GB10 (10-bit Bayer GBRG Unpacked) ← 당신 카메라
│   │   ├─ RGGB (8-bit Bayer)
│   │   └─ BGGR (8-bit Bayer)
│   │
│   └─ 기타 Raw
│
├─ 🟢 YUV 포맷 (처리된 색 공간)
│   ├─ YUYV (YUV 4:2:2) ← Bayer에서 변환됨
│   ├─ NV12
│   └─ YV12
│
├─ 🔵 압축 포맷
│   ├─ MJPEG (Motion JPEG) ← RGB에서 압축
│   └─ H.264
│
└─ 🟡 RGB 포맷
    ├─ RGB24
    └─ BGR24

비교표:
┌───────────┬──────┬────────┬────────────┬───────────┬──────────┐
│   포맷    │ 타입 │ Bayer? │  처리필요  │   크기    │ 보기쉬움 │
├───────────┼──────┼────────┼────────────┼───────────┼──────────┤
│   pGAA    │ Raw  │   ✅   │ 디베이어링 │ 384 KB    │    ❌    │
│   GB10    │ Raw  │   ✅   │ 디베이어링 │ 614 KB    │    ❌    │
│   YUYV    │ 처리 │   ❌   │ RGB 변환만 │ 614 KB    │    ⚠️    │
│   MJPEG   │ 압축 │   ❌   │    없음    │ ~50 KB    │    ✅    │
└───────────┴──────┴────────┴────────────┴───────────┴──────────┘


================================================================================
4. 이미지 처리 파이프라인
================================================================================

카메라에서 이미지가 나오는 전체 과정:

┌──────────────────────────────────────────────────────────┐
│  1단계: 하드웨어 센서 (항상 Bayer 출력)                 │
├──────────────────────────────────────────────────────────┤
│                                                            │
│   📷 카메라 센서 (GBRG Bayer 필터)                       │
│        ↓                                                  │
│   [센서 데이터 읽기]                                      │
│        ↓                                                  │
│   pGAA 또는 GB10 (10-bit Bayer GBRG)                     │
│                                                            │
└──────────────────────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────────┐
│  2단계: ISP (Image Signal Processor) - 선택적           │
├──────────────────────────────────────────────────────────┤
│                                                            │
│   🔧 디베이어링 (Bayer → RGB)                            │
│        ↓                                                  │
│   G B    →    R=200                                       │
│   R G         G=107                                       │
│               B=50                                        │
│        ↓                                                  │
│   RGB 이미지 (내부, 아직 메모리에만)                     │
│                                                            │
└──────────────────────────────────────────────────────────┘
                     ↓
┌──────────────────────────────────────────────────────────┐
│  3단계: 포맷 변환 - 선택적                              │
├──────────────────────────────────────────────────────────┤
│                                                            │
│   RGB → YUV 변환 → YUYV 출력                             │
│      또는                                                 │
│   RGB → JPEG 압축 → MJPEG 출력                           │
│      또는                                                 │
│   RGB → RGB24 출력                                        │
│                                                            │
└──────────────────────────────────────────────────────────┘

당신 카메라 (V4L2 인터페이스):
┌──────────────────────────────────────────────────────────┐
│  📷 센서 (Bayer GBRG)                                    │
│       ↓                                                   │
│  ✅ pGAA/GB10 출력                                       │
│       ↓                                                   │
│  🚫 ISP 우회 (비활성화)                                  │
│       ↓                                                   │
│  ❌ YUYV/MJPEG 불가                                      │
└──────────────────────────────────────────────────────────┘

libcamera 사용 시:
┌──────────────────────────────────────────────────────────┐
│  📷 센서 (Bayer GBRG)                                    │
│       ↓                                                   │
│  🔧 GPU ISP (활성화)                                     │
│       ↓                                                   │
│  ✅ YUYV, MJPEG, RGB 등 출력 가능                        │
└──────────────────────────────────────────────────────────┘


================================================================================
5. 메모리 구조 (1차원 배열)
================================================================================

GBRG 패턴은 1차원 배열로 저장됩니다.

640x480 이미지 예시:

2D 이미지 (시각화):
┌─────────────────────────────────────────┐
│ G B G B G B ... (640픽셀) ... G B │  행0
│ R G R G R G ... (640픽셀) ... R G │  행1
│ G B G B G B ... (640픽셀) ... G B │  행2
│ R G R G R G ... (640픽셀) ... R G │  행3
│ ...                                     │
│ (480행)                                 │
└─────────────────────────────────────────┘

1D 배열로 저장:
raw[0]    = G (0행 0열)
raw[1]    = B (0행 1열)
raw[2]    = G (0행 2열)
raw[3]    = B (0행 3열)
...
raw[639]  = B (0행 639열)
raw[640]  = R (1행 0열)  ← 다음 행 시작!
raw[641]  = G (1행 1열)
raw[642]  = R (1행 2열)
...
raw[1280] = G (2행 0열)  ← 또 다음 행
...

인덱스 계산 공식:
┌─────────────────────────────┐
│  index = y × width + x      │
└─────────────────────────────┘

예시 (640x480):
┌──────────┬───────────────────┬────────┬──────┐
│  좌표    │   계산            │ 인덱스 │  값  │
├──────────┼───────────────────┼────────┼──────┤
│ (0, 0)   │ 0×640 + 0         │    0   │  G   │
│ (1, 0)   │ 0×640 + 1         │    1   │  B   │
│ (2, 0)   │ 0×640 + 2         │    2   │  G   │
│ (0, 1)   │ 1×640 + 0         │  640   │  R   │
│ (1, 1)   │ 1×640 + 1         │  641   │  G   │
│ (0, 2)   │ 2×640 + 0         │ 1280   │  G   │
└──────────┴───────────────────┴────────┴──────┘

2×2 블록 읽기 (디베이어링용):
x, y := 0, 0
width := 640

g1 := raw[y*width + x]         // raw[0]   = G
b  := raw[y*width + x+1]       // raw[1]   = B
r  := raw[(y+1)*width + x]     // raw[640] = R
g2 := raw[(y+1)*width + x+1]   // raw[641] = G


================================================================================
6. 디베이어링 원리
================================================================================

디베이어링 = Bayer → RGB 변환

----------------------------
간단한 방법: 2×2 → 1픽셀
----------------------------

GBRG 패턴 2×2 블록:
┌───┬───┐
│ G │ B │  값: G=100, B=50
├───┼───┤
│ R │ G │  값: R=200, G=105
└───┴───┘

RGB 계산:
R = 200
G = (100 + 105) / 2 = 102.5 ≈ 102
B = 50

결과: RGB(200, 102, 50) ← 1픽셀!

----------------------------
더 정교한 방법: 보간
----------------------------

주변 픽셀들을 고려해서 더 정확한 색 계산:

      G B G
      R G R
      G B G

중앙 픽셀이 G일 때:
- G = 원본 값 사용
- R = 좌우 R 픽셀 평균
- B = 위아래 B 픽셀 평균

중앙 픽셀이 R일 때:
- R = 원본 값 사용
- G = 상하좌우 G 픽셀 평균
- B = 대각선 B 픽셀 평균

----------------------------
패턴별 처리
----------------------------

GBRG:  (0,0)=G (1,0)=B (0,1)=R (1,1)=G
RGGB:  (0,0)=R (1,0)=G (0,1)=G (1,1)=B
BGGR:  (0,0)=B (1,0)=G (0,1)=G (1,1)=R
GRBG:  (0,0)=G (1,0)=R (0,1)=B (1,1)=G

→ 알고리즘은 동일, 시작 오프셋만 다름!


================================================================================
7. 현재 프로젝트 상황
================================================================================

프로젝트 구조:
meraca/
├── main.go              # 메인 진입점
├── frame.raw            # 캡처된 프레임 (384KB)
└── v4l2/                # V4L2 API 래퍼
    ├── v4l2.go          # 핵심 기능
    ├── stream.go        # 스트리밍
    └── type.go          # 상수

----------------------------
현재 상태
----------------------------
✅ /dev/video0 열기 성공
✅ pGAA 포맷으로 캡처
✅ frame.raw 파일 생성 (384,000 바이트)
❌ 이미지로 볼 수 없음 (Raw 데이터)

지원 포맷:
[0] pGAA (0x41414770): 10-bit Bayer GBGB/RGRG Packed
[1] GB10 (0x30314247): 10-bit Bayer GBGB/RGRG

현재 사용: pGAA (Packed)

----------------------------
frame.raw 정보
----------------------------
크기: 384,000 바이트
해상도: 640 × 480
포맷: pGAA (10-bit Bayer GBRG Packed)
Bytes per line: 800

계산:
640픽셀 × 10bit ÷ 8 = 800 바이트/행
800 바이트/행 × 480행 = 384,000 바이트 ✅

----------------------------
다음 단계 옵션
----------------------------

옵션 1: pGAA → RGB → JPEG 변환 구현
  1. pGAA Unpacking (10-bit → 픽셀 값 추출)
  2. 디베이어링 (GBRG → RGB)
  3. JPEG 인코딩

옵션 2: libcamera 사용
  libcamera-still -o image.jpg
  → 간단하지만 V4L2 공부 안 됨

옵션 3: OpenCV 사용
  Go bindings로 OpenCV 디베이어링 활용

----------------------------
변환 흐름도
----------------------------

frame.raw (pGAA)
      ↓
[1. Unpack]
10-bit 픽셀 값 추출
      ↓
[2. Debayer]
GBRG → RGB
      ↓
[3. Encode]
RGB → JPEG
      ↓
image.jpg (볼 수 있음!)


================================================================================
용어 정리
================================================================================

Bayer 패턴      : 센서의 색 필터 배열 (GBRG, RGGB 등)
pGAA            : 10-bit Bayer GBRG Packed 포맷
GB10            : 10-bit Bayer GBRG Unpacked 포맷
Packed          : 빈틈없이 압축 저장 (4픽셀=5바이트)
Unpacked        : 여유있게 저장 (1픽셀=2바이트)
디베이어링      : Bayer → RGB 변환
ISP             : Image Signal Processor (이미지 처리 칩)
YUYV            : YUV 4:2:2 포맷 (Bayer에서 변환됨)
MJPEG           : Motion JPEG (압축 포맷)
V4L2            : Video for Linux 2 (리눅스 비디오 API)
fourCC          : Four Character Code (포맷 식별자)


================================================================================
참고 링크
================================================================================

V4L2 문서: https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/
Bayer 패턴: https://en.wikipedia.org/wiki/Bayer_filter
libcamera: https://libcamera.org/


================================================================================
8. V4L2 표준과 추상화
================================================================================

V4L2 = Linux 커널 표준 API

모든 V4L2 호환 카메라는 동일한 인터페이스를 사용합니다.

----------------------------
V4L2 구조
----------------------------

┌─────────────────────────────┐
│   애플리케이션              │
│   (EnumFormats, SetFormat)  │
└─────────────┬───────────────┘
              │ V4L2 API (표준)
              │ - VIDIOC_ENUM_FMT
              │ - VIDIOC_G_FMT
              │ - VIDIOC_S_FMT
              │ - 구조체: FmtDesc, Format 등
┌─────────────▼───────────────┐
│   V4L2 커널 서브시스템      │
│   (Linux Kernel)             │
└─────────────┬───────────────┘
              │
      ┌───────┴────────┐
      │                │
┌─────▼──────┐  ┌─────▼──────┐
│ RPi Camera │  │  Logitech  │
│   Driver   │  │   Driver   │
└─────┬──────┘  └─────┬──────┘
      │                │
┌─────▼──────┐  ┌─────▼──────┐
│ RPi Camera │  │  USB Webcam│
│  Hardware  │  │  Hardware  │
└────────────┘  └────────────┘

----------------------------
핵심 개념
----------------------------

1. API는 100% 동일
   모든 V4L2 카메라는 같은 함수, 같은 구조체 사용

   VIDIOC_ENUM_FMT   → 지원 포맷 나열
   VIDIOC_G_FMT      → 현재 포맷 얻기
   VIDIOC_S_FMT      → 포맷 설정
   VIDIOC_QUERYCAP   → 카메라 기능 확인

   → 한 번 작성하면 모든 V4L2 카메라에서 작동!

2. 드라이버가 하드웨어 차이 숨김

   추상화 계층:
   애플리케이션: "지원 포맷 알려줘" (VIDIOC_ENUM_FMT)
        ↓
   V4L2 커널: "드라이버야, 너 뭐 지원해?"
        ↓
   드라이버: "나는 pGAA, GB10 줄 수 있어"
        ↓
   V4L2 커널: (표준 FmtDesc 구조체에 담아서 반환)
        ↓
   애플리케이션: (표준 구조체 읽기)

3. 차이점은 "데이터 내용"

   API는 동일, 반환 값만 다름:

   Raspberry Pi Camera:
   ┌──────────────────────────────┐
   │ [0] pGAA - 10bit Bayer       │
   │ [1] GB10 - 10bit Bayer       │
   └──────────────────────────────┘

   Logitech Webcam:
   ┌──────────────────────────────┐
   │ [0] YUYV - YUV 4:2:2         │
   │ [1] MJPG - Motion JPEG       │
   └──────────────────────────────┘

   → 같은 EnumFormats() 함수로 읽음!

----------------------------
FFI (Foreign Function Interface) 패턴
----------------------------

Go 애플리케이션이 C 커널 API와 통신하는 방법:

┌─────────────────────────────┐
│   Go 애플리케이션           │
│   type FmtDesc struct {...} │
└──────────────┬──────────────┘
               │ syscall.Syscall()
               │ unsafe.Pointer()
┌──────────────▼──────────────┐
│   Linux Kernel (C)          │
│   struct v4l2_fmtdesc {...} │
└─────────────────────────────┘

핵심:
- Go 구조체 = C 구조체의 메모리 레이아웃 복제
- 타입 이름은 달라도 됨
- 바이트 배치만 정확하면 OK

----------------------------
C → Go 타입 변환
----------------------------

C 타입          →  Go 타입
──────────────────────────────
__u8            →  uint8 또는 byte
__u16           →  uint16
__u32           →  uint32
__u64           →  uint64
__s32           →  int32
char[N]         →  [N]byte

예시:
C:
struct v4l2_fmtdesc {
    __u32   index;           // 4 bytes
    __u32   type;            // 4 bytes
    __u32   flags;           // 4 bytes
    __u8    description[32]; // 32 bytes
    __u32   pixelformat;     // 4 bytes
    __u32   reserved[4];     // 16 bytes
};                           // 총 64 bytes

Go:
type FmtDesc struct {
    Index       uint32      // 4 bytes
    Type        uint32      // 4 bytes
    Flags       uint32      // 4 bytes
    Description [32]byte    // 32 bytes
    PixelFormat uint32      // 4 bytes
    Reserved    [4]uint32   // 16 bytes
}                           // 총 64 bytes

----------------------------
정리
----------------------------

✅ API = 표준 (모든 카메라 동일)
✅ 구조체 = 표준 (FmtDesc, Format 등)
✅ 드라이버 = 하드웨어 추상화
❌ 카메라마다 찾을 필요 없음
⚠️ 지원 포맷만 다름 (런타임 확인)

V4L2 = Linux의 "카메라 공통 언어"


================================================================================
9. 문서 참고 가이드
================================================================================

V4L2 개발 시 참고할 문서들 (우선순위순)

----------------------------
1. Linux Kernel V4L2 API 공식 문서 ⭐⭐⭐⭐⭐
----------------------------

URL:
https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/

장점:
- ✅ 가장 권위있고 정확함
- ✅ 구조체마다 상세 설명
- ✅ 예제 코드 포함
- ✅ 버전별 차이 명시

주요 페이지:
vidioc-querycap.html    → 디바이스 기능 확인
vidioc-enum-fmt.html    → 포맷 열거 (FmtDesc)
vidioc-g-fmt.html       → 포맷 얻기/설정 (Format)
vidioc-reqbufs.html     → 버퍼 요청
vidioc-streamon.html    → 스트리밍 제어
pixfmt-bayer.html       → Bayer 포맷 설명

언제 보나:
- 새 ioctl 추가할 때
- 구조체 정의 확인할 때
- 동작 원리 이해할 때

----------------------------
2. videodev2.h 헤더 파일 ⭐⭐⭐⭐
----------------------------

위치:
/usr/include/linux/videodev2.h

온라인:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/videodev2.h

장점:
- ✅ 모든 구조체 정의
- ✅ 상수, enum 정의
- ✅ 주석으로 설명 포함
- ✅ 최신 버전 확인 가능

주요 내용:
// 구조체 정의
struct v4l2_capability
struct v4l2_fmtdesc
struct v4l2_format
struct v4l2_buffer

// 상수 정의
#define V4L2_CAP_VIDEO_CAPTURE
#define V4L2_BUF_TYPE_VIDEO_CAPTURE

// ioctl 명령
#define VIDIOC_QUERYCAP
#define VIDIOC_ENUM_FMT

언제 보나:
- Go 구조체 변환할 때
- 상수 값 확인할 때
- 정확한 필드 타입 확인할 때

----------------------------
3. V4L2 튜토리얼/가이드 ⭐⭐⭐
----------------------------

추천 자료:

LinuxTV Wiki:
https://www.linuxtv.org/wiki/

V4L2 Programming:
https://linuxtv.org/downloads/v4l-dvb-apis/

장점:
- ✅ 초보자 친화적
- ✅ 단계별 설명
- ✅ 실전 예제 많음

언제 보나:
- 처음 V4L2 배울 때
- 전체 흐름 이해할 때
- 예제 코드 찾을 때

----------------------------
4. 기존 오픈소스 프로젝트 ⭐⭐⭐
----------------------------

추천 프로젝트:

Go 라이브러리:
github.com/korandiz/v4l       → 깔끔한 구조
github.com/blackjack/webcam   → 실용적 구현

C 예제:
v4l-utils (v4l2-ctl 소스)    → 완성도 높음
FFmpeg libavdevice            → 프로덕션 수준

장점:
- ✅ 실제 동작하는 코드
- ✅ 엣지 케이스 처리 참고
- ✅ 설계 패턴 학습

언제 보나:
- 구현 막힐 때
- 에러 처리 방법 찾을 때
- 아키텍처 참고할 때

----------------------------
문서 활용 전략
----------------------------

상황별 가이드:

새 기능 구현 시:
1. Kernel 문서 읽기 (개념 이해)
   ↓
2. videodev2.h 보기 (구조체 확인)
   ↓
3. 오픈소스 참고 (구현 예시)
   ↓
4. 직접 구현

버그 수정 시:
1. 오픈소스 코드 확인 (비교)
   ↓
2. Kernel 문서 재확인 (스펙 검증)
   ↓
3. videodev2.h (정확한 값 확인)

학습 시:
1. 튜토리얼 (전체 흐름)
   ↓
2. Kernel 문서 (상세 이해)
   ↓
3. 오픈소스 (실전 감각)

----------------------------
실전 예시: VIDIOC_ENUM_FMT 구현
----------------------------

1단계: Kernel 문서
URL: https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/vidioc-enum-fmt.html

읽을 내용:
- Description (무엇을 하는가)
- ioctl 사용법
- 반환 값
- 에러 코드

2단계: videodev2.h
struct v4l2_fmtdesc {
    __u32   index;
    __u32   type;
    __u32   flags;
    __u8    description[32];
    __u32   pixelformat;
    __u32   mbus_code;
    __u32   reserved[3];
};

→ Go로 변환

3단계: 참고 구현
github.com/korandiz/v4l/device.go
→ 에러 처리 방식 참고

----------------------------
빠른 검색 팁
----------------------------

Google 검색 패턴:
"v4l2" + "구조체/함수명" + "site:kernel.org"

예:
v4l2_fmtdesc site:kernel.org
VIDIOC_ENUM_FMT site:kernel.org

GitHub 검색:
language:Go "v4l2" "구조체명"

예:
language:Go "v4l2" "fmtdesc"

----------------------------
필수 북마크
----------------------------

필수 3개:
1. https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/
2. https://git.kernel.org/.../videodev2.h
3. https://github.com/korandiz/v4l

보조 자료:
- LinuxTV Wiki
- V4L2 메일링 리스트 아카이브

----------------------------
정리
----------------------------

우선순위:
1. 🥇 Kernel 문서 (개념, 스펙)
2. 🥈 videodev2.h (정확한 정의)
3. 🥉 오픈소스 (실전 구현)
4. 튜토리얼 (입문용)

실전 팁:
- Kernel 문서 = 권위있는 레퍼런스
- videodev2.h = 정확한 스펙
- 오픈소스 = 실용적 구현

가장 중요한 문서:
https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/

이 문서 하나만 제대로 읽어도 충분합니다!


================================================================================
마지막 업데이트: 2026-02-13
================================================================================
